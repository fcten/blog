---
title: DeepSeek R1 入门指南
date: 2025-01-30 15:28:14
tags:
- AI
- LLM
- DeepSeek
categories:
- 数智科技编年史
mathjax: true
---

> 本文由 DeepSeek R1 翻译自 [Primers • DeepSeek R1](https://aman.ai/primers/ai/deepseek-R1/)

## 概述

[DeepSeek-R1](https://arxiv.org/abs/2501.12948) 是一个里程碑式的具备推理能力的大语言模型（LLMs）。它在 MIT 许可证下发布，与 OpenAI 的 o1 系列等闭源巨头相媲美，并开创了一种基于强化学习的框架，专为推理任务设计。
  
DeepSeek-R1 利用 [DeepSeekMath](https://arxiv.org/abs/2402.03300) 中引入的 **Group Relative Policy Optimization (GRPO)** 技术，取代了传统的 PPO 方法，使训练更加高效和可扩展。同时，它还利用 [DeepSeek-V2](https://arxiv.org/pdf/2405.04434) 中引入的 **Multihead Latent Attention (MLA)**，通过将 Key-Query-Value (KQV) 矩阵投影到低维潜在空间，显著降低了长上下文处理中的计算和内存开销。

DeepSeek-R1 展示了如何仅通过强化学习使推理能力自然出现，而无需依赖大规模的监督微调。通过 **GRPO**、FP8 量化和新兴的 CoT 推理等创新，该模型不仅与闭源模型相竞争，还推动了 AI 的透明度和可访问性。随着研究社区在这些创新基础上不断进步，DeepSeek-R1 标志着一种转变：即一种高效、基于推理的 AI 正在向所有人开放。

本简明介绍探索其架构、多阶段训练流水线、GRPO 机制以及推理能力的涌现行为，并探讨如何通过蒸馏将这些推理能力传递给更小的模型。

<!--more-->

## 基础架构

DeepSeek-R1 基于 [DeepSeek-V2](https://arxiv.org/pdf/2405.04434) 引入的进步，集成了优化训练效率和推理性能的尖端架构创新。这些基础增强包括专家混合（MoE）、多头潜在注意力（MLA）、FP8 量化和多词元预测（MTP）。

本节详细介绍了从 DeepSeek-V2 到 DeepSeek-R1 演变的架构组件，突出了使 DeepSeek-R1 成为领先的开放源代码模型，能够在推理效率和性能上与专有替代品相媲美的改进。

### 专家混合（MoE）

#### 概述

专家混合（Mixture of Experts, MoE）机制通过在每个推理步骤中选择性激活模型总参数的一部分，实现计算节省的同时保持模型质量。这种方法使得在不按比例增加计算成本的情况下，能够扩展模型参数规模

#### 从 DeepSeek-V2 到 DeepSeek-R1 的改进

DeepSeek-V2 中的 MoE：
- DeepSeek-V2 引入了 **DeepSeekMoE**，这是一种经过优化的 MoE 架构，旨在实现经济高效的训练和推理。
- 采用精细粒度的专家分割策略，在提升专家专业化能力的同时降低了计算开销。
- 实现设备限制路由机制，将专家选择范围限制在可用设备的一个子集中，从而降低分布式训练中的通信成本。
- 引入辅助损失用于负载均衡，确保令牌分配在各个专家之间更加均匀。

DeepSeek-R1 的改进：
- DeepSeek-R1 进一步优化了 MoE 框架，针对推理密集型任务提升了专家利用率：
  - **动态专家分配**：根据输入令牌上下文动态分配专家，减少过度专业化并提升泛化能力。
  - **强化学习引导的路由**：与 DeepSeek-V2 不同，DeepSeek-R1 使用强化学习来指导专家利用，确保计算负载均衡。
  - **稀疏激活约束**：实施更严格的稀疏性约束以降低激活成本，同时保持表达能力。

#### 数学表示

混合专家模型（MoE）的专家选择过程由门控函数 $G(x)$ 控制，该函数将输入词元 $x$ 路由至特定专家 $E_k$：

$$
G(x) = \text{softmax}(W_g x)
$$

每个元都由选定的专家处理，他们的输出汇总为：

$$
y = \sum_{k \in K} G_k(x) E_k(x)
$$

此外，应用负载均衡损失以确保专家的均衡利用并最小化计算瓶颈。

### 多头潜在注意力（MLA）

#### 概述

多头潜在注意力（MLA）通过将键-查询-值（KQV）矩阵投影到低维潜在空间，提高了效率，显著降低了计算和内存成本。

#### 从 DeepSeek-V2 到 DeepSeek-R1 的改进

DeepSeek-V2 中的 MLA：
- 作为低秩键值联合压缩技术引入，MLA 显著降低了与传统的多头注意力（MHA）相关的内存开销。
- 允许将 KV 缓存压缩成更紧凑的潜在向量，与标准注意力机制相比，存储需求降低 93.3%。
- 相较于 DeepSeek 67B，提高了 5.76 倍的推理效率，使得长上下文处理更加可行。

DeepSeek-R1 的改进：
- **混合潜在投影**：DeepSeek-R1 根据词元上下文复杂度动态缩放潜在投影空间，确保最佳内存使用。
- **分层缓存**：引入了一种高级缓存机制，允许在多个词元之间重用潜在投影，减少冗余计算。
- **自适应注意力缩放**：该模型动态调整注意力权重分布，提高长上下文理解能力。

#### 数学表示

多头潜在注意力（MLA）机制通过引入潜在空间投影来改变标准注意力计算：

1. 计算键、查询和值矩阵：$K, Q, V = W_k X, W_q X, W_v X$
2. 投影到低维潜在空间: $K_L, Q_L, V_L = W_L K, W_L Q, W_L V$

通过将注意力复杂度从 $O(N^2)$ 降低到 $O(Nd_L)$ ，其中 $d_L$ 是潜在空间的维度，MLA显著提高了效率。

### FP8 量化

#### 概述

DeepSeek-R1 利用 8 位浮点数（FP8）量化来减少内存使用和计算成本，同时保持数值稳定性。

#### DeepSeek-R1 的改进

- **自适应位宽缩放**：根据网络不同层的计算需求，动态调整位精度。
- **基于损失的量化**：使用对损失敏感的缩放函数，确保在不同的计算阶段保持数值精度。

#### 数学表示

FP8 量化涉及一个缩放因子 $S$，用于调整输入值：

$$
x_q = \text{clip}( \text{round}(x / S), -127, 127)
$$

其中，$S$ 是根据损失梯度动态优化的，以防止数值不稳定。

### 多词元预测（MTP）

#### 概述

多词元预测（Multi-Token Prediction, MTP）使 DeepSeek-R1 能够并行预测多个令牌，显著提高了推理速度。

#### 关键特性

- **并行解码**：扩展了自回归框架，允许在同一上下文中并行预测多个令牌。
- **令牌采样和重排**：从概率分布中对多令牌输出进行采样，并根据连贯性重新排序。
- **动态预测地平线**：根据模型置信度调整每步预测的令牌数量。

#### DeepSeek-R1 的改进

- **强化学习引导的令牌选择**：确保多令牌预测的连贯性，并减少错误传播。
- **分层令牌验证**：根据不确定性估计动态调整每步预测的令牌数量。

#### 数学表示

预测函数遵循自回归形式：

$$
P(y_t | x) = \prod_{t=1}^{T} P(y_t | y_{<t}, x)
$$

通过引入并行解码，DeepSeek-R1 将推理复杂度从 $O(T)$ 降低到 $O(T/k)$，其中 $k$ 是每步预测的令牌数量。

## 训练流程：从预训练到推理

DeepSeek-R1 采用多阶段训练流水线，精心设计以最大化其推理能力的同时最小化计算成本。该过程包括由特定任务损失函数和奖励机制指导的多个不同阶段。

### 第一阶段：使用监督微调（Supervised Fine-Tuning, SFT）进行冷启动

DeepSeek-R1 从对 V3-Base 模型进行监督微调开始，使用高质量的链式思维（Chain-of-Thought, CoT）示例。这些示例通过少量样本提示、人工标注和 DeepSeek-R1-Zero 输出的优化精心整理而成。

**与推荐系统中的冷启动对比：**
- 在推荐系统中，“冷启动问题”指的是为新用户或历史数据有限的新商品提供准确推荐的挑战。重点在于通过学习用户偏好或商品属性来缓解数据稀疏性。
- 相比之下，DeepSeek-R1 的冷启动旨在解决如何初始化一个具有结构化推理和可读性的大型语言模型的挑战。通过对整理后的数据进行微调，模型建立了对链式思维推理的基础理解，克服了仅基于强化学习训练中观察到的不稳定现象。

**冷启动的优势：**
- **可读性**： DeepSeek-R1-Zero 在可读性和语言混合方面表现欠佳。相比之下，冷启动阶段引入了结构化的输出格式：
> &lt;reasoning_process&gt; CoT explanation &lt;/reasoning_process&gt;
> &lt;summary&gt; Final Answer &lt;/summary&gt;
- **对齐**： 冷启动数据引入了人类的先验知识，加速收敛并提升了在推理密集型任务上的性能。

DeepSeek-R1 从对 V3-Base 模型进行监督微调开始，使用高质量的 CoT 示例。这些示例通过少量样本提示、人工标注和 DeepSeek-R1-Zero 输出的优化精心整理而成。

**监督微调的损失函数：**
模型使用监督交叉熵损失进行微调：

$$
L_{\text{SFT}} = -\sum_{i=1}^{n} \log P_{\theta}(o_i|q, \{o_1, \dots, o_{i-1}\})
$$

其中：
- $o_i$：输出序列中的第 \(i^{th}\) 个令牌
- $q$：输入查询
- $o_1, ..., o_{i-1}$：之前生成的令牌

### 第二阶段：强化学习（Reinforcement Learning, RL）

强化学习是DeepSeek-R1推理演化的基石。模型通过奖励而非整理好的数据集进行学习，在数千次迭代中实现自我提升。

#### 概述

DeepSeek的强化学习方法从根本上受到自博弈（self-play）范式的启发，类似于在国际象棋等游戏中训练AI模型。传统上，用于复杂推理任务的AI模型依赖于由标注的人类示例组成的大数据集。然而，这些数据集往往缺乏全面覆盖，并且可能不包含最优解。强化学习通过让模型自主探索解决方案，基于奖励驱动的反馈机制来优化策略，从而克服了这一限制。

考虑一个训练下棋的AI模型。与其从固定的历史对弈数据集中学习不同，AI仅被赋予国际象棋的基本规则。然后进行自我博弈，不断尝试各种走法。起初，模型会执行次优的动作导致失败。然而，通过反复博弈，它识别出有效的策略，并强化那些带来胜利的动作，舍弃无效的走法。这种基于强化学习的试错过程使AI能够发展出超越人类直觉的战略。

DeepSeek将这种方法应用于需要大量推理的领域，如数学问题解决。AI不是在显式的数学推导数据集上训练，而是被赋予基本的数学规则，并要求自主解决问题。模型系统地探索各种解决方案路径，强化那些产生正确答案的方法，舍弃无效的策略。随着时间的推移，这种方法增强了AI在数学推理和基于逻辑的任务中的能力，超越了传统的监督学习方法。强化学习的自我改进特性促进了新问题解决策略的发现，从而在数学推理和逻辑任务中表现出色。

#### 奖励机制

DeepSeek-R1使用两种主要的奖励函数：
- **准确性奖励（Accuracy Rewards）**
  - 评估确定性任务（如数学问题和代码生成输出）的正确性。例如：
    - 数学领域，模型的最终答案会被验证到一个事实值。
    - 对于编程，单元测试会评估生成代码的有效性。
- **格式奖励（Format Rewards）**
  - 通过奖励符合指定CoT格式的输出，鼓励一致的推理结构。例如：
> &lt;reasoning_process&gt; Step-by-step explanation &lt;/reasoning_process&gt;
> &lt;answer&gt; Final Output &lt;/answer&gt;

## 组相对策略优化（Group Relative Policy Optimization, GRPO）

组相对策略优化（GRPO），在[DeepSeekMath：推动开放语言模型数学推理极限](https://arxiv.org/abs/2402.03300)中提出，是一种在 DeepSeek-R1 开发中发挥关键作用的强化学习方法。它首次在《DeepSeekMath：推动开放语言模型数学推理极限》中提出，作为一种简化且更高效的替代传统策略优化技术（如近端策略优化 PPO）的方法。

GRPO 已从 DeepSeekMath 中的数学推理优化器发展成为 DeepSeek-R1 的核心优化技术，推动着跨多样任务的高级推理能力。通过消除批评模型，利用基于群体的优势，以及结合多阶段强化学习优化，GRPO 使 DeepSeek-R1 成为最强大的开源推理模型之一。

GRPO 是 DeepSeek-R1 的 RL 流程的核心，提供了一种轻量级且强大的优化机制。其关键创新包括：
- 移除批评模型，这显著减少了内存开销。
- 通过基于群体的优势估计稳定政策更新。
- 高效训练同时与基于 PPO 的方法相比保持强大性能。

从 DeepSeekMath 的初始提出到 DeepSeek-R1 的精炼实现，GRPO 经历了多次增强，包括多阶段强化学习、改进的奖励建模和优化的策略。本节详细介绍了 GRPO 的数学公式、其实现以及在 DeepSeek-R1 中的作用。

### GRPO 的演变：从 DeepSeekMath 到 DeepSeek-R1

#### 第一阶段：DeepSeekMath（数学强化学习）中的 GRPO

GRPO 最初在 DeepSeekMath 中被引入，用于优化数学推理模型。

它用基于组的奖励归一化技术替换了 PPO 的评论家模型，使训练更高效同时保持稳定性。

奖励函数主要评估数学正确性，使用结构化评估指标。

#### 第二阶段：DeepSeek-R1-Zero（自进化推理）中的 GRPO

使用 DeepSeek-R1-Zero，GRPO 应用时无需任何监督微调（SFT）——从头开始使用纯强化学习塑造推理行为。

该模型自学了推理技能，如逐步解决问题和自我验证。

然而，DeepSeek-R1-Zero 存在可读性问题（例如，非结构化推理输出、语言混合）。

#### 第三阶段：DeepSeek-R1 中的 GRPO（优化推理与冷启动）

DeepSeek-R1 引入了一个多阶段强化学习（RL）流水线，在应用 GRPO 之前，结合少量冷启动微调。

奖励模型扩展到数学之外，包括一般推理任务。

添加了语言一致性奖励，以提升连贯性和可读性。

### GRPO 工作原理

GRPO通过基于组的归一化（而不是使用评论模型）来修改传统的策略优化方法。这使得在减少计算开销的同时能够实现高效且稳定的策略更新。

#### GRPO直观理解

要理解GRPO，从逆向工程的角度分析其数学公式是有用的。这些方程的复杂性可能会误导人；实际上，GRPO由三个主要部分组成：

$$
J_{\text{GRPO}} = \min([\text{块1}], [\text{块2}]) - [\text{块3}]
$$

其中：
- **块1**对应GRPO目标函数求和中的第一个项： $\rho_i A_i = \frac{\pi_\theta(o_i|q)}{\pi_{\theta_{old}}(o_i|q)} A_i.$ 这代表策略优化的主要目标：确保更新后的策略 $\pi_\theta$ 比旧的策略 $\pi_{\theta_{old}}$ 更好。其核心原则很简单：新的策略在期望上应该胜过旧策略。
- **块2**对应 $\rho_i A_i$ 的裁剪版本： $\text{clip}(\rho_i, 1 - \epsilon, 1 + \epsilon) A_i.$ 这一部分源自PPO，作为保护措施以防止过度更新。通过取块1和这个裁剪值中的较小者，GRPO确保了训练的稳定性，并防止策略更新过于夸张。
- **块3**对应于GRPO方程中的KL散度正则化项： $\beta D_{\text{KL}}(\pi_\theta || \pi_{\text{ref}})$ 。这项强制执行新策略与参考策略之间的相似性，防止优化过程偏离原始分布太远，并确保受控的更新。

GRPO取得成功的一个最值得注意的方面是其对优势计算方法的设计。传统的PPO使用学习的价值网络结合时间差分学习来计算优势，需要额外的记忆和计算来维护一个单独的评论模型。相反，GRPO从根本上简化了这一点，通过直接在组内比较采样的动作，并利用统计归一化来计算优势。这种基于组的方法消除了对价值网络的需求，从而将内存开销减少了约一半，同时与相对于其他方法评估数学解决方案的核心原则保持一致。

这一设计选择在数学推理任务中被证明特别有效。通过直接使用组内比较，GRPO增强了模型开发结构化推理策略的能力。实证结果表明，这种方法不仅提高了数学推理基准上的性能，还保持了训练的稳定性和计算效率。消除评论网络去除了从学习的价值函数中可能存在的偏差，使其特别适合需要对多个解决方案路径进行客观评估的领域。

此外，“组”方面在GRPO中指的是对一组采样输出的期望值进行计算，然后取平均以稳定训练。A中的归一化（均值和标准差）最初看起来可能复杂，但它只是遵循机器学习中常用的常规归一化技术。

因此，在剥离了索引、下标和超参数之后，GRPO简化为在<strong>策略改进</strong>与<strong>控制机制</strong>之间的简单平衡，强化了为什么它被认为是高效且直观的优化方法。

#### 数学表达

GRPO的目标函数为：

$$
J_{\text{GRPO}}(\theta) = \mathbb{E}_{q \sim P(Q), \{o_i\}_{i=1}^G \sim \pi_{\theta_{old}}(O|q)} \left[ \frac{1}{G} \sum_{i=1}^G \min\left(\rho_i A_i, \text{clip}(\rho_i, 1-\epsilon, 1+\epsilon) A_i\right) - \beta D_{\text{KL}}(\pi_\theta \| \pi_{\text{ref}}) \right]
$$

其中：
- $\rho_i$ 是似然比，表示新策略与旧策略之间的偏离程度：$\rho_i = \frac{\pi_\theta(o_i|q)}{\pi_{\theta_{old}}(o_i|q)}$
- $A_i$ 是基于组的优势函数，对采样输出上的奖励进行归一化：$A_i = \frac{r_i - \text{mean}(r_1, ..., r_G)}{\text{std}(r_1, ..., r_G)}$
- $D_{\text{KL}}(\pi_\theta \| \pi_{ref})$ 是一个KL正则化项，用于限制更新范围。
- $G$ 是组大小（每个查询采样的输出数量）。
- $\epsilon$ 控制裁剪程度以防止过度更新。
- $\beta$ 控制KL正则化的强度。

### 步骤分解

#### 似然比 $\rho_i$

衡量在新策略与旧策略下生成输出 $o_i$ 的概率变化程度： $\rho_i = \frac{\pi_\theta(o_i|q)}{\pi_{\theta_{\text{old}}}(o_i|q)}$

#### 优势函数 $A_i$

通过一组采样的输出来估计优势函数，而不依赖于单独的价值网络（评论器）： $A_i = \frac{r_i - \text{mean}(r_1, ..., r_G)}{\text{std}(r_1, ..., r_G)}$

这降低了训练的不稳定性，并提高了效率。

#### 裁剪机制

防止 drastic 的策略更新，以避免训练不稳定： $\text{clip}(\rho_i, 1-\epsilon, 1+\epsilon)$

#### KL散度惩罚项

确保策略保持在参考分布附近： $\beta D_{\text{KL}}\bigl(\pi_\theta \;\|\; \pi_{\text{ref}}\bigr)$

防止模式坍缩和过度的策略漂移。

### 实现细节

#### 训练设置

- GRPO通过为每个查询采样多个输出，并在组内计算奖励来进行实现。
- 奖励的均值和标准差提供了一个用于训练的归一化基准。

#### 奖励函数设计

- 在DeepSeekMath中：奖励主要基于数学正确性。
- 在DeepSeek-R1中：奖励函数扩展为包括：
  - **准确性奖励**：评估通用推理任务（如编码、科学、逻辑）的正确性。
  - **格式奖励**：确保使用`<think>`和`<answer>`标签进行结构化推理。

#### 优化过程

- 模型针对每个查询采样多个输出，计算似然比和优势估计，并使用裁剪的目标函数更新策略。

#### 效率考虑

- 移除了评论模型，减少了内存消耗。
- 批处理计算组内采样，提高了效率。
- 迭代强化学习的精炼过程，使持续改进成为可能。

### 应用

#### DeepSeek-R1-Zero: 从头开始的强化学习

DeepSeek-R1-Zero在没有任何预训练的情况下应用了GRPO，使得模型能够自我学习推理能力。

模型自然发展出了自验证和反思的能力。

然而，这也带来了可读性和语言混合的问题，需要进一步优化。

#### DeepSeek-R1: 多阶段强化学习

为了优化DeepSeek-R1-Zero，DeepSeek-R1引入了以下步骤：
- **冷启动微调**
  - 首先对高质量的Chain-of-Thought（CoT）示例进行微调。
  - 确保结构化推理和更好的可读性。
- **基于GRPO的强化学习**
  - 使用GRPO来精炼数学、逻辑和通用问题解决能力。
  - 添加语言一致性奖励，以防止语言混合。
- **最终强化学习优化**
  - 在强化学习之后，通过拒绝采样生成更好的训练数据。
  - 进行最后的GRPO优化阶段，使用多样化的提示。

### PPO vs DPO vs KTO vs APO vs GRPO

1. **PPO（Proximal Policy Optimization）**：
   - **功能**：一种限制语言模型与之前版本模型之间偏差程度的强化学习算法，从而优化语言模型。
   - **实现方式**：通过从当前模型采样生成内容，并使用奖励模型对其进行评估，然后利用这些反馈进行更新。
   - **实际挑战**：在分布式环境中可能会变得缓慢且不稳定。

2. **DPO（Direct Preference Optimization）**：
   - **功能**：通过最小化观察到的人类偏好负对数似然，使语言模型与人类反馈保持一致。
   - **数据需求**：需要成对的偏好数据。
   - **与KTO的对比**：尽管DPO效果显著，但KTO在不依赖配对偏好数据的情况下，性能更优或与其相当。

3. **KTO（Kahneman-Tversky Optimizer）**：
   - **功能**：将Kahneman-Tversky的人类价值函数应用于语言模型设置，并利用该函数直接最大化模型输出的效用。
   - **数据需求**：无需成对的偏好数据，仅需了解给定输入下输出是否为理想或非理想结果。
   - **实际应用性**：在现实场景中更容易部署，特别是在理想/非理想结果数据较为丰富的环境中。
   - **模型对比**：在从1B到30B的各种规模模型上，其性能与直接偏好优化方法相当甚至更优。

4. **APO（Alignment via Preference Optimization）**：
   - **功能**：引入了一系列对比目标函数，明确考虑了模型与其偏好数据集之间的关系。其中包括APO-zero（通过增加理想输出并减少非理想输出来提升性能），以及APO-down（根据特定质量阈值对模型进行微调）。
   - **数据需求**：与通过受控方法（如CLAIR）创建的配对偏好数据集配合使用效果显著，并支持在具有挑战性的数据集上实现稳定的对齐。
   - **实际应用性**：擅长将强大的模型与最少对比的偏好对齐，在诸如MixEval-Hard等具有挑战性的指标上表现优异，同时提供稳定且可解释的训练动态。
   - **模型对比**：在多个基准测试中超越了传统的对齐目标函数，并缩小了与GPT4-turbo在使用CLAIR偏好训练时45%的性能差距。

5. **GRPO（Group-based Reward Proximal Optimization）**：
   - **功能**：PPO的一种变体，通过基于群体评分估计基线，从而提高了内存和计算效率，并增强了模型的数学推理能力。
   - **数据需求**：利用针对每个查询生成的多输出分组奖励，并对这些分数进行标准化以指导优化过程。
   - **实际应用性**：与PPO相比，更注重减少训练资源消耗并提升强化学习稳定性。
   - **模型对比**：在GSM8K和MATH等任务上表现出色，优于同类规模的其他模型，并且提升了模型在领域内和领域外推理任务的表现。

#### 表格比较

| **维度**       | **PPO**                                                                                     | **DPO**                                                                                     | **KTO**                                                                                     | **APO**                                                                                     | **GRPO**                                                                                   |
|----------------|-------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| **目标**        | 在防止策略大幅更新的同时，最大化预期奖励。                                                 | 基于人类偏好的二分类优化策略。                                                             | 根据Kahneman-Tversky优化方法，基于效用最大化的模型对齐。                                             | 通过特定控制的偏好基概率调整实现稳定的锚定对齐。                                           | 利用分组相对优势，并移除评论网络。                                                         |
| **输入数据**    | 环境状态和奖励。                                                                          | 成对的人类偏好数据。                                                                       | 输出的理想性二进制标签。                                                                   | 最小对比的偏好对或其他需要定制锚定的数据集。                                               | 通过奖励模型为分组的大语言模型输出评分。                                                   |
| **学习机制**    | 带有截断代理目标的策略梯度。                                                               | 成对偏好的交叉熵优化。                                                                     | 在无配对数据的情况下，最大化理想与非理想的概率比值。                                             | 使用APO-zero或APO-down等变体来平衡理想与非理想的概率变化。                                 | 组合归一化和策略梯度，并移除评论网络。                                                     |
| **输出**        | 环境中的动作。                                                                            | 基于人类偏好的对齐响应。                                                                   | 优化以符合人类效用的模型输出。                                                             | 对齐到偏好对质量的精炼输出，控制优化动力学。                                               | 优化推理能力，减少计算开销。                                                               |
| **数据需求**    | 需要环境奖励。                                                                            | 需要成对的偏好数据。                                                                       | 仅需了解给定输入的理想/非理想结果。                                                       | 效果上佳，尤其适用于通过如CLAIR等受控方法生成的配对偏好数据集。                             | 利用每条查询的多输出分组奖励，并对这些评分进行归一化以引导优化。                               |
| **模型复杂度**  | 高，由于需要在奖励最大化与策略约束之间取得平衡。                                           | 中等；使用简化的二元偏好目标。                                                             | 简化了对齐过程，仅关注理想性判断。                                                         | 根据数据集-模型关系选择合适的APO变体，适应性强且情境感知能力高。                           | 通过分组评分减少开销。                                                                     |
| **稳定性**      | 依赖截断机制以避免不稳定。                                                                | 稳定，因为它直接优化偏好。                                                                  | 稳定，专注于未配对的理想性调整。                                                            | 提供稳健的训练稳定性，在混合质量数据集上的扩展能力更好。                                  | 通过分组奖励归一化实现稳定。                                                               |
| **性能**        | 在具有明确奖励信号的任务上表现强劲，但在分布式设置中易出现不稳定。                         | 对于直接偏好对齐任务有效。                                                                  | 相比基于偏好的方法，在无配对数据需求的情况下表现竞争性或更优。                                  | 在如MixEval-Hard等基准测试中表现出色，结合CLAIR和APO可实现>7.65%的性能提升（2024-06-01分隔）。| 在数学推理任务上表现出色，并提供计算效率。                                                   |
| **显著优势**    | 广泛应用于强化学习环境中，在基于奖励的优化方面表现良好。                                   | 直接针对偏好进行优化，无需单独的奖励模型。                                                     | 高效处理二进制数据，避免对配对数据的依赖。                                                   | 结合自适应动力学和稳定训练，针对特定数据集实现精细对齐，即使面对复杂输入也能做到 nuanced alignment（细腻对齐）。| 简化奖励聚合；适合推理密集型任务。                                                         |
| **适用场景**    | 强化学习环境，其中奖励信号预先定义。                                                       | 具有丰富的人类反馈配对的情况。                                                             | 现实世界环境中，理想/非理想结果的定义广泛。                                                   | 需要与细腻、最小对比的偏好实现精确对齐的任务，尤其适用于缩小竞争模型（如GPT4-turbo）之间的性能差距。| 数学推理或资源有限的训练设置。                                                             |

## 新兴推理行为

在训练过程中，DeepSeek-R1 发展现了一些显著的推理模式：

- **反思**：重新审视并修正中间步骤。
- **自我校正**：实时识别并修复错误。
- **顿悟时刻**：暂停并重新评估以发现新的解决方案。

例如，在解决方程 \(x^2 - 5x + 6 = 0\) 时，模型可能会先提出不正确的因数分解，随后暂停反思，最终推导出正确的解 \(x = 2\) 和 \(x = 3\)。下表展示了 R1 在推理过程中出现“顿悟时刻”的情况：

![推理过程](/images/2.png)

## 知识蒸馏：在紧凑模型中进行推理

DeepSeek-R1 的推理能力被迁移到更小的模型（如 Qwen-7B、Llama-8B）中，实现了最先进的性能：

- **教师-学生范式**：通过 DeepSeek-R1 训练的小型模型输出结果，几乎无额外计算开销。
- **效率提升**：蒸馏后的模型保留了推理能力，且在与更大的非推理模型（如 GPT-4o）的对比中表现更优。

下表展示了经过蒸馏的 R1 模型在推理相关基准测试中的表现：

![蒸馏模型表现](/images/3.png)

## 结果展示

下图摘自论文 [原始论文链接](https://arxiv.org/abs/2501.12948)，展示了 DeepSeek R1 在多个基准测试中与 OpenAI 模型的表现对比：

![性能对比](/images/1.png)

## 开放问题

如图所示（[来源](https://huggingface.co/blog/open-r1)），如果您能访问一个强大的基础模型和高质量的数据混合，构建一个强大的推理模型现在非常简单：

![推理模型](/images/reasoningLLM.png)

尽管 DeepSeek-R1 取得了显著进展，但仍有一些开放性问题需要解决：

- **数据收集**：推理专用的数据集是如何筛选和整理的？了解数据来源和选择标准对于复制和改进模型性能至关重要。
- **模型训练**：DeepSeek 未公开 R1 的训练代码，这使得最佳超参数的选择以及其在不同规模模型中的差异性成为未知数。
- **扩展规律**：推理模型的训练中计算与数据之间的权衡关系是什么？识别这些关系对于优化未来模型至关重要。

### Open-R1

尽管 DeepSeek-R1 提供了开源权重，但其使用的训练数据集和代码仍为专有。上述问题推动了 [Open-R1](https://huggingface.co/blog/open-r1) 项目的启动，旨在系统性地重建 R1 的数据和训练流程、验证其声明，并推动开放推理模型的发展。通过开源项目 [GitHub 链接](https://github.com/huggingface/open-r1)，Open-R1 致力于透明化 RL 如何提升推理能力，与开源社区共享可复现的见解，并为未来的模型奠定基础，使其能够利用这些技术。

#### Open-R1 的目标

1. **复现 R1-Distill 模型**：通过从 DeepSeek-R1 蒸馏出高质量的推理数据集，Open-R1 力求真实地复制 R1-Distill 模型。
2. **复现强化学习训练流程**：DeepSeek-R1 的关键组成部分是基于 RL 的训练方法。Open-R1 将通过整理大规模数学、推理和代码数据集来实现这一过程。
3. **推进多阶段训练**：从基础模型到 SFT 再到 RL 的完整过渡将是一个重要里程碑，确保可复现的规模化的训练方法。

下图展示了 Open-R1 的计划：

![Open-R1 计划](/images/open-r1-steps.png)

#### 对社区的影响

- **可访问的推理模型**：通过 Open-R1 的合成数据集，任何人都可以利用现有的或新的大语言模型（LLMs）进行推理能力的对齐优化。
- **探索数学以外领域**：虽然数学推理是主要关注点，但 Open-R1 还将探索编程和科学应用等领域，如医学，在这些领域中推理模型可以产生重要影响。

## 推理数据集

以下是两个重要的推理数据集：

1. [OpenThoughts](https://huggingface.co/datasets/open-thoughts/OpenThoughts-114k)：包含 114,000 个样本，涵盖数学、代码和科学领域。
2. [R1-Distill-SFT](https://huggingface.co/datasets/ServiceNow-AI/R1-Distill-SFT)：从 R1-32B 蒸馏出的 170 万个样本，在 NuminaMath 和 Allen AI 的 Tulu 上进行稳定对齐。

## 参考文献

以下是一些相关论文和文章：

1. [DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning](https://arxiv.org/abs/2501.12948)
2. [DeepSeek-R1: A Pure RL-based Reasoning Model](https://www.linkedin.com/pulse/deepseek-r1-pure-rl-based-reasoning-model-jayant-kumar-yfopc/?trackingId=Tc70aMqJS42SK6oiIPqBZA%3D%3D)
3. [DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models](https://arxiv.org/abs/2402.03300)
4. [DeepSeek-V3 Technical Report](https://arxiv.org/abs/2412.19437)
5. [Open-R1: a fully open reproduction of DeepSeek-R1](https://huggingface.co/blog/open-r1)